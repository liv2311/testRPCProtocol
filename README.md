Я ранее не работал с микроконтроллерами и не имел опыта работы с RTOS, поэтому текущая реализация использует стандартные потоки C++ для имитации параллельной работы. Такой подход позволил проверить корректность работы кода в Qt. При необходимости данную реализацию можно адаптировать для работы с RTOS на реальном микроконтроллере, заменив потоки на задачи, условные переменные на очереди сообщений и используя другие примитивы, предоставляемые RTOS.

Для запуска в линуксе выполнил команду

@astra:~$ socat -d -d PTY,link=/tmp/ttyV0,raw,echo=0 PTY,link=/tmp/ttyV1,raw,echo=0

для создания связанных виртуальных портов (UART) для тестирования


Описание реализации:

- Физический уровень (PhysicalUART.cpp/PhysicalUART.h)
Реализован через класс PhysicalUART, который открывает UART-порт, настраивает скорость и параметры.
Поддерживаются функции send() и receive(), работа с массивами байт.

- Канальный уровень (channel.cpp/channel.h)
Класс Channel формирует пакеты транспортного уровня.
Канальный уровень проверяет целостность через CRC, буферизует входящие байты и собирает полные пакеты.

- Транспортный уровень (transport.cpp/transport.h)
Класс Transport реализует упрощенный RPC: регистрация функций, отправка запросов, ожидание ответа.
Использует std::mutex и std::condition_variable для синхронизации ожидания ответов.
Функция checkIncoming() проверяет входящие пакеты, вызывает зарегистрированные функции и отправляет результат.

- Уровень приложения (main.cpp)
Создаются два "устройства", каждое работает в отдельном потоке.
Поток reader обрабатывает входящие сообщения, поток sender отправляет RPC-запросы.
Демонстрируются функции sum и multiply, а также обработка неизвестной функции.

async_queue.h
Аналог функционала RTOS-очередей
Для организации безопасной очереди сообщений между потоками или задачами:
синхронизация доступа, ожидание данных без постоянного опроса (polling), асинхронная обработка, чтобы отправитель не блокировался, а получатель мог получать данные, когда они появляются.


Недостатки и предложения по улучшению:
- В сообщении транспортного уровня ID запроса хранится в 1 байте  -  максимум 256 запросов
Улучшение - сделать 2 байта

- Нет явной длины аргументов, идут просто до конца пакета, могут быть проблемы при повреждении пакета
Добавить длину аргументов

- Нет сериализации передаваемых данных (сведений о типах и тд)
JSON либо более специфичное

- Не передается версия протокола, при его изменении может быть не корректная работа
Добавить версию протокола

- Отсутствие подтверждения доставки
Канальный уровень проверяет CRC, но при ошибке просто отбрасывает пакет
Протокол повторно не отправляет повреждённые пакеты, но и нет проверки на повторные сообщения

- Нет идентиикации отправителя пакета, в дополнение к ID, понадобится если отправителей будет несколько







